# grammar.lark

########################################################################################################################
#   ENTRY POINT  #
##################

?start: translation_unit

translation_unit: external_declaration*

external_declaration: declaration
#                    | decl1
#                    | decl2
#
#decl1: _SEMICOLON
#decl2: _SEMICOLON

########################################################################################################################
#  DECLARATIONS & DEFINITIONS  #
################################

# ISO C++ Declarations
#declaration_seq: declaration | declaration_seq declaration

declaration: block_declaration
           | function_definition
#           | template_declaration
#           | explicit_instantiation
#           | explicit_specialization
#           | linkage_specification
#           | namespace_definition
           | empty_declaration
           | attribute_declaration

empty_declaration: _SEMICOLON

block_declaration: simple_declaration
#                 | asm_definition
#                 | namespace_alias_definition
#                 | using_declaration
#                 | using_directive
#                 | static_assert_declaration
                 | alias_declaration
                 | opaque_enum_declaration

######################
# ALIAS DECLARATION  #
######################
alias_declaration: USING IDENTIFIER EQUAL type_id _SEMICOLON
# Example: using newTypeName = existingTypeName;

# uncomment once abstract_declarator is normalized, and make abstract_declarator non-optional
#type_id: type_specifier_seq abstract_declarator?
type_id: type_specifier_seq

########################
#  SIMPLE DECLARATION  #
########################
simple_declaration: attribute_specifier? decl_specifier_seq init_declarator_list? _SEMICOLON

#############################
#  OPAQUE ENUM DECLARATION  #
#############################
opaque_enum_declaration: enum_key attribute_specifier? IDENTIFIER enum_base? _SEMICOLON

enum_key: ENUM
        | ENUM CLASS
        | ENUM STRUCT

enum_base: COLON type_specifier_seq

enumerator_list: enumerator_definition
               | enumerator_list _COMMA enumerator_definition

enumerator_definition: enumerator
                     | enumerator EQUAL constant_expression

enumerator: IDENTIFIER

##################################################
#  ATTRIBUTE DECLARATION & ATTRIBUTE SPECIFIER   #
##################################################
attribute_declaration: attribute_specifier _SEMICOLON

attribute_specifier: _LBRACKET _LBRACKET attribute_list? _RBRACKET _RBRACKET

attribute_list: attribute (_COMMA attribute)* ELLIPSIS?

attribute: attribute_token attribute_argument_clause?

attribute_token: IDENTIFIER 
               | attribute_scoped_token

attribute_scoped_token: attribute_namespace SCOPE IDENTIFIER

attribute_namespace: IDENTIFIER

attribute_argument_clause: _LPAREN balanced_token_seq _RPAREN

balanced_token_seq: balanced_token+

balanced_token: _LPAREN   balanced_token_seq _RPAREN
              | _LBRACKET balanced_token_seq _RBRACKET
              | _LBRACE    balanced_token_seq _RBRACE
#             | any token other than a parenthesis, a bracket, or a brace

########################################################################################################################
function_definition: decl_specifier_seq declarator compound_statement

#declaration: declaration_specifier_list init_declarator_list? _SEMICOLON

init_declarator_list: init_declarator ( _COMMA init_declarator )*

init_declarator:  declarator init_suffix?

init_suffix: EQUAL initializer

init_list: initializer (_COMMA initializer)*

initializer: expression
           | _LBRACE init_list? _RBRACE


########################
#  DECLARATOR (Named)  #
########################

declarator: ptr_list? reference_operator? direct_declarator

reference_operator: BIT_AND     -> lvalue_ref
                  | AND         -> rvalue_ref

ptr_list: ptr_operator+

ptr_operator: (scope_qualifier SCOPE)? STAR type_qualifier_list? -> ptr

scope_qualifier: IDENTIFIER (SCOPE IDENTIFIER)*


direct_declarator: IDENTIFIER
                 | _LPAREN declarator _RPAREN
                 | direct_declarator array_suffix
                 | direct_declarator function_suffix

array_suffix:    _LBRACKET constant_expression _RBRACKET
function_suffix: _LPAREN   parameter_list?     _RPAREN


########################################################################################################################
#  ABSTRACT DECLARATORS  (Unnamed)  #
#####################################

abstract_declarator: ptr_operator abstract_declarator  # allows *, C::*, &, && chains
                   | direct_abstract_declarator
                   |                                   # EMPTY: just the specifiers (e.g., "int")

direct_abstract_declarator: _LPAREN abstract_declarator _RPAREN
                          | direct_abstract_declarator array_suffix
                          | direct_abstract_declarator function_suffix
                          | array_suffix            # base-case: allow starting with [] …
                          | function_suffix         # … or with ()

########################################################################################################################
# Parameters  #
##########################

parameter_list: parameter ( _COMMA parameter )* ( _COMMA ELLIPSIS )?
              | ELLIPSIS                     // "..."

parameter: decl_specifier_seq param_declarator?  default_arg?   // specs + name? + default_arguments?

# Parameter - Named or Unnamed
?param_declarator: declarator | abstract_declarator

default_arg: EQUAL initializer

########################################################################################################################
#  DECLARATION SPECIFIER List #
###############################
# ISO C++ SPECIFIER
type_specifier: trailing_type_specifier
#              | class_specifier
#              | enum_specifier

trailing_type_specifier: simple_type_specifier
#                       | elaborated_type_specifier
#                       | typename_specifier
#                       | cv_qualifier

type_specifier_seq: (type_specifier attribute_specifier?)+

trailing_type_specifier_seq: (trailing_type_specifier attribute_specifier?)+



simple_type_specifier: CHAR
                     | CHAR16_T
                     | CHAR32_T
                     | WCHAR_T
                     | BOOL
                     | SHORT
                     | INT
                     | LONG
                     | SIGNED
                     | UNSIGNED
                     | FLOAT
                     | DOUBLE
                     | VOID
                     | AUTO
#                     | decltype_specifier
#                     | SCOPE? nested_name_specifier? type_name                  # user-defined types
#                     | SCOPE? nested_name_specifier template simple_template_id # user-defined templates

#decltype_specifier: decltype _LPAREN expression _RPAREN

########################################################################################################################
# Non-ISO C++

decl_specifier_seq: declaration_specifier+

?declaration_specifier:  storage_class_specifier
                       | type_specifier
                       | type_qualifier
                       | function_specifier
                       | FRIEND
                       | TYPEDEF
                       | CONSTEXPR
                       | CONSTEVAL

storage_class_specifier: EXTERN | STATIC | THREAD_LOCAL | REGISTER
                       | MUTABLE # This is NOT a real storage class [TEMPORARY]


type_qualifier_list: type_qualifier+

type_qualifier: CONST | VOLATILE | RESTRICT

simple_type_specifier_list: simple_type_specifier+

#?type_specifier: simple_type_specifier
#               | elaborated_type_specifier
#
#simple_type_specifier: VOID | CHAR | INT | FLOAT | DOUBLE | BOOL
#                     | SIGNED | UNSIGNED | SHORT | LONG | AUTO
#                     | WCHAR_T | WCHAR16_T | WCHAR32_T
#                     | IDENTIFIER # Typedef Names - Creates Massive Ambiguity ;-;
#                     PLEASE DO NOT UNCOMMENT


#elaborated_type_specifier: (UNION | CLASS | STRUCT)  scope_qualifier? IDENTIFIER class_body?           -> class_type
#                         |  ENUM   (CLASS | STRUCT)? scope_qualifier? IDENTIFIER enum_base? enum_body? -> enum_type


function_specifier: INLINE | VIRTUAL | EXPLICIT | NOEXCEPT | OVERRIDE | FINAL

########################################################################################################################
# ELABORATE TYPE BODIES #
#########################

# CLASS / STRUCT BODY
class_body: _LBRACE member_declaration* _RBRACE

?member_declaration: declaration                                 // inside class / struc
                   | access_specifier COLON  -> access_specifier // public:, private:, protected:

access_specifier: PUBLIC | PRIVATE | PROTECTED

## ENUM BODY
#enum_body: _LBRACE enumerator_list? _RBRACE
#enumerator_list: enumerator ( _COMMA enumerator )* _COMMA?
#enumerator: IDENTIFIER (EQUAL constant_expression)?
#
#
## ENUM UNDERLYING TYPE
#enum_base: COLON simple_type_specifier_list


########################################################################################################################
#  EXPRESSIONS  #
#################

# Used For Array Sizes
constant_expression: conditional_expression

######################
#  PRECEDENCE ORDER  #  All the boolean/arithmetic precedence levels.
######################

# Lowest precedence (comma operator), left-associative
?expression: assignment_expression (_COMMA assignment_expression)*

# Assignment: right-associative; allow any unary lhs (covers *p = x, a[i] = x, ++x = y is still rejected later)
assignment_expression: conditional_expression
                     | unary assign_op assignment_expression

# Ternary sits between assignment and ||; middle uses full expression, right side is conditional_expression
conditional_expression: logic_or ( TERNARY expression COLON conditional_expression )?

# || down to unary — same as you had, but now fed by conditional_expression above
logic_or: logic_or OR logic_and                          
        | logic_and

logic_and: logic_and AND equality                        
         | equality

equality: equality (EQ | NEQ) relational                 
        | relational

relational: relational (LT | GT | LE | GE) sum             
          | sum

sum: sum (PLUS | MINUS) product                  
   | product

product: product (STAR | SLASH | PERCENT) unary         
       | unary

unary: (INCREMENT | DECREMENT | PLUS | MINUS | NOT | BIT_NOT | STAR | BIT_AND) unary
     | postfix

# Open-ended chaining of calls, indexing, member access, ++/--
postfix: primary post_op*

primary: IDENTIFIER
       | literal
       | _LPAREN expression _RPAREN

post_op: _LPAREN argument_list? _RPAREN  -> function_call
       | _LBRACKET expression _RBRACKET  -> array_access
       | _DOT IDENTIFIER                 -> member_access
       | ARROW IDENTIFIER                -> ptr_to_member_access
       | INCREMENT                       -> increment
       | DECREMENT                       -> decrement

argument_list: expression ( _COMMA expression )*

literal: INT_LITERAL
       | FLOAT_LITERAL
       | CHAR_LITERAL
       | STRING_LITERAL
       | BOOL_LITERAL
       | NULLPTR

###########################################
# Helper for all the assignment operators
assign_op: EQUAL
         | PLUS_EQUAL
         | MINUS_EQUAL
         | STAR_EQUAL
         | SLASH_EQUAL
         | PERCENT_EQUAL
         | SHL_EQUAL
         | SHR_EQUAL
         | BIT_AND_EQUAL
         | BIT_OR_EQUAL
         | BIT_XOR_EQUAL



########################################################################################################################
#  STATEMENTS  #
################

?statement: jump_statement
          | selection_statement
          | iteration_statement
          | expression_statement
          | labeled_statement
          | compound_statement
          | declaration

compound_statement: _LBRACE statement* _RBRACE

expression_statement: expression? _SEMICOLON


selection_statement: if_statement
                   | switch_statement

if_statement: _IF _LPAREN expression _RPAREN statement
            | _IF _LPAREN expression _RPAREN statement ELSE statement

switch_statement: SWITCH _LPAREN expression _RPAREN statement

iteration_statement: FOR _LPAREN for_init? expression? _SEMICOLON expression? _RPAREN statement
                   | WHILE _LPAREN expression _RPAREN statement
                   | DO statement WHILE _LPAREN expression _RPAREN _SEMICOLON

for_init: declaration
        | expression_statement

?jump_statement: return_statement
               | break_statement
               | continue_statement
               | goto_statement

return_statement: RETURN [expression] _SEMICOLON
break_statement: BREAK _SEMICOLON
continue_statement: CONTINUE _SEMICOLON
goto_statement: GOTO IDENTIFIER _SEMICOLON

labeled_statement: IDENTIFIER COLON statement
                 | CASE constant_expression COLON statement
                 | DEFAULT COLON statement


########################################################################################################################
#  TERMINALS (TOKENS)  #
########################

############################
#  IDENTIFIERS & LITERALS  #
############################

IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
INT_LITERAL: /0|[1-9][0-9]*/
FLOAT_LITERAL: /([0-9]+\.[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?/
CHAR_LITERAL:   /'([^'\\]|\\.)'/
STRING_LITERAL: /"(\\"|[^"\\])*"/
BOOL_LITERAL:   "true" | "false"
NULLPTR:        "nullptr"

COMMENT_LINE: "//" /[^\n]*/
COMMENT_BLOCK: "/*" /(.|\n)*?/ "*/"

##############################
#   KEYWORDS (CONTROL-FLOW)  #
##############################
_IF:         "if"
ELSE:       "else"
SWITCH:     "switch"
CASE:       "case"
DEFAULT:    "default"
FOR:        "for"
WHILE:      "while"
DO:         "do"
BREAK:      "break"
CONTINUE:   "continue"
RETURN:     "return"
GOTO:       "goto"

######################
#  KEYWORDS (TYPES)  #
######################
INT:        "int"
FLOAT:      "float"
DOUBLE:     "double"
CHAR:       "char"
WCHAR_T:    "wchar_t"
CHAR16_T:   "char16_t"
CHAR32_T:   "char32_t"
VOID:       "void"
BOOL:       "bool"
AUTO:       "auto"
SIGNED:     "signed"
UNSIGNED:   "unsigned"
SHORT:      "short"
LONG:       "long"
CONST:      "const"
CONSTEXPR:  "constexpr"
CONSTEVAL:  "consteval"
VOLATILE:   "volatile"
STATIC:     "static"
EXTERN:     "extern"
MUTABLE:    "mutable"
REGISTER:   "register"
RESTRICT:   "restrict"
INLINE:     "inline"
VIRTUAL:    "virtual"
EXPLICIT:   "explicit"
NOEXCEPT:   "noexcept"
FINAL:      "final"
OVERRIDE:   "override"
THREAD_LOCAL: "thread local"

##################
#    KEYWORDS    #
##################
CLASS:      "class"
STRUCT:     "struct"
UNION:      "union"
ENUM:       "enum"
NAMESPACE:  "namespace"
TEMPLATE:   "template"
TYPEDEF:    "typedef"
USING:      "using"
FRIEND:     "friend"
PUBLIC:     "public"
PRIVATE:    "private"
PROTECTED:  "protected"

#################
#   OPERATORS   #
#################
PLUS:       "+"
MINUS:      "-"
STAR:       "*"
SLASH:      "/"
PERCENT:    "%"
EQUAL:      "="
ELLIPSIS:    "..."
PLUS_EQUAL:    "+="
MINUS_EQUAL:   "-="
STAR_EQUAL:    "*="
SLASH_EQUAL:   "/="
PERCENT_EQUAL: "%="
SHL_EQUAL: "<<="
SHR_EQUAL: ">>="
BIT_AND_EQUAL: "&="
BIT_OR_EQUAL: "|="
BIT_XOR_EQUAL: "^="


LT:         "<"
GT:         ">"
LE:         "<="
GE:         ">="
EQ:         "=="
NEQ:        "!="

AND:        "&&"
OR:         "||"
NOT:        "!"
BIT_AND:    "&"
BIT_OR:     "|"
BIT_NOT:    "~"
BIT_XOR:    "^"
SHL:        "<<"
SHR:        ">>"

INCREMENT:  "++"
DECREMENT:  "--"
ARROW:      "->"
TERNARY:    "?"
SCOPE:      "::"
COLON:      ":"

##################
#   PUNCTUATION  #
##################
_LPAREN:     "("
_RPAREN:     ")"
_LBRACE:     "{"
_RBRACE:     "}"
_LBRACKET:   "["
_RBRACKET:   "]"
_SEMICOLON:  ";"
_COMMA:      ","
_DOT:        "."

###################
#  MISCELLANEOUS  #
###################
HASH:            "#"
INCLUDE:         "include"
DEFINE:          "define"

########################################################################################################################
#  RULESET  #
#############

%import common.WS
%ignore WS
%ignore COMMENT_LINE
%ignore COMMENT_BLOCK