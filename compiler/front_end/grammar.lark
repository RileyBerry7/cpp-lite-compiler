# grammar.lark


########################################################################################################################
#  A.1 KEYWORDS   #                                                                             #  TERMINALS (TOKENS)  #
###################                                                                             ########################

##############################
#   KEYWORDS (CONTROL-FLOW)  #
##############################
_IF:         "if"
ELSE:       "else"
SWITCH:     "switch"
CASE:       "case"
DEFAULT:    "default"
FOR:        "for"
WHILE:      "while"
DO:         "do"
BREAK:      "break"
CONTINUE:   "continue"
RETURN:     "return"
GOTO:       "goto"
TRY:        "try"
CATCH:      "catch"
THROW:      "throw"

######################
#  KEYWORDS (TYPES)  #
######################

INT:        "int"
FLOAT:      "float"
DOUBLE:     "double"
CHAR:       "char"
WCHAR_T:    "wchar_t"
CHAR16_T:   "char16_t"
CHAR32_T:   "char32_t"
VOID:       "void"
BOOL:       "bool"
AUTO:       "auto"
SIGNED:     "signed"
UNSIGNED:   "unsigned"
SHORT:      "short"
LONG:       "long"
CONST:      "const"
CONSTEXPR:  "constexpr"
CONSTEVAL:  "consteval"
VOLATILE:   "volatile"
STATIC:     "static"
EXTERN:     "extern"
MUTABLE:    "mutable"
REGISTER:   "register"
RESTRICT:   "restrict"
INLINE:     "inline"
VIRTUAL:    "virtual"
EXPLICIT:   "explicit"
NOEXCEPT:   "noexcept"
FINAL:      "final"
OVERRIDE:   "override"
THREAD_LOCAL: "thread local"
TYPENAME:   "typename"
NEW:        "new"
CONST_CAST:       "const_cast"
STATIC_CAST:      "static_cast"
DYNAMIC_CAST:     "dynamic_cast"
REINTERPRET_CAST: "reinterpret_cast"
TYPEID          : "typeid"


#################################
#    KEYWORDS (DECLARATIONS)    #
#################################
CLASS:      "class"
STRUCT:     "struct"
UNION:      "union"
ENUM:       "enum"
NAMESPACE:  "namespace"
TEMPLATE:   "template"
TYPEDEF:    "typedef"
USING:      "using"
FRIEND:     "friend"
PUBLIC:     "public"
PRIVATE:    "private"
PROTECTED:  "protected"
STATIC_ASSERT: "static_assert"
ASM:        "asm"
DELETE:     "delete"
OPERATOR:   "operator"
DECLTYPE:    "decltype"
THIS:       "this"

#################
#   OPERATORS   #
#################
PLUS:       "+"
MINUS:      "-"
STAR:       "*"
SLASH:      "/"
PERCENT:    "%"
EQUAL:      "="
ELLIPSIS:    "..."
PLUS_EQUAL:    "+="
MINUS_EQUAL:   "-="
STAR_EQUAL:    "*="
SLASH_EQUAL:   "/="
PERCENT_EQUAL: "%="
SHL_EQUAL: "<<="
SHR_EQUAL: ">>="
BIT_AND_EQUAL: "&="
BIT_OR_EQUAL: "|="
BIT_XOR_EQUAL: "^="


LT:         "<"
GT:         ">"
LE:         "<="
GE:         ">="
EQ:         "=="
NEQ:        "!="

AND:        "&&"
OR:         "||"
NOT:        "!"
BIT_AND:    "&"
BIT_OR:     "|"
BIT_NOT:    "~"
BIT_XOR:    "^"
SHL:        "<<"
SHR:        ">>"

INCREMENT:  "++"
DECREMENT:  "--"
ARROW:      "->"
ARROW_STAR: "->*"
DOT_STAR:   ".*"
TERNARY:    "?"
SCOPE:      "::"
COLON:      ":"

NEW_ARRAY: "new[]"
DELETE_ARRAY: "delete[]"

CALL:      "()"
SUBSCRIPT: "[]"

SIZEOF: "sizeof"
ALIGNOF: "alignof"

##################
#   PUNCTUATION  #
##################
_LPAREN:     "("
_RPAREN:     ")"
_LBRACE:     "{"
_RBRACE:     "}"
_LBRACKET:   "["
_RBRACKET:   "]"
_SEMICOLON:  ";"
_COMMA:      ","
_DOT:        "."

###################
#  MISCELLANEOUS  #
###################
HASH:            "#"
INCLUDE:         "include"
DEFINE:          "define"
HASH_HASH: "##"
LT_COLON: "<:"
COLON_GT: ":>"
LT_PERCENT: "<%"
PERCENT_GT: "%>"
PERCENT_COLON: "%:"
PERCENT_COLON_PERCENT_COLON: "%:%:"

############################
#  IDENTIFIERS & LITERALS  #
############################


INT_LITERAL: /0|[1-9][0-9]*/
FLOAT_LITERAL: /([0-9]+\.[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?/
CHAR_LITERAL:   /'([^'\\]|\\.)'/
STRING_LITERAL: /"(\\.|[^"\\])*"/
BOOL_LITERAL:   "true" | "false"
NULLPTR:        "nullptr"
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
ambiguous_identifier: IDENTIFIER

COMMENT_LINE: "//" /[^\n]*/
COMMENT_BLOCK: "/*" /(.|\n)*?/ "*/"

# Digits & prefixes
ZERO: "0"
HEX_PREFIX: /0[xX]/

# “OTHER_NON_WS” fallback
OTHER_NON_WS: /[^\s]/

########################################################################################################################
#  A.2 LEXICAL CONVENTIONS   # -> ISO C++ lexical convention heavily reduced.
##############################

# ===== Preprocessing tokens =====
preprocessing_token: OTHER_NON_WS
#                   | IDENTIFIER
#                   | CHAR_LITERAL
#                   | USER_DEFINED_CHARACTER_LITERAL
#                   | STRING_LITERAL
#                   | USER_DEFINED_STRING_LITERAL
#                   | preprocessing_op_or_punc

token: IDENTIFIER
     | keyword
     | literal
     | operator
     | punctuator


#preprocessing_op_or_punc: _LBRACE          | _RBRACE              | _LBRACKET
#                        | _RBRACKET        | _LPAREN              | _RPAREN
#                        | _DOT             | _COMMA               | _SEMICOLON
#                        | COLON            | SCOPE                | TERNARY
#                        | PLUS             | MINUS                | STAR
#                        | SLASH            | PERCENT              | EQUAL
#                        | LT               | GT                   | NOT
#                        | BIT_AND          | BIT_OR               | BIT_XOR
#                        | BIT_NOT          | AND                  | OR
#                        | EQ               | NEQ                  | LE
#                        | GE               | SHL                  | SHR
#                        | INCREMENT        | DECREMENT            | ARROW
#                        | DOT_STAR         | ARROW_STAR           | ELLIPSIS
#                        | PLUS_EQUAL       | MINUS_EQUAL          | STAR_EQUAL
#                        | SLASH_EQUAL      | PERCENT_EQUAL        | BIT_AND_EQUAL
#                        | BIT_OR_EQUAL     | BIT_XOR_EQUAL        | SHL_EQUAL
#                        | SHR_EQUAL        | HASH                 | HASH_HASH
#                        | LT_COLON         | COLON_GT             | LT_PERCENT
#                        | PERCENT_GT       | PERCENT_COLON        | PERCENT_COLON_PERCENT_COLON
#                        | NEW              | DELETE               | AND_ALT
#                        | OR_ALT           | NOT_ALT              | COMPL_ALT
#                        | BITAND_ALT       | BITOR_ALT            | XOR_ALT
#                        | AND_EQ_ALT       | OR_EQ_ALT            | NOT_EQ_ALT
#                        | XOR_EQ_ALT

literal: INT_LITERAL    | CHAR_LITERAL  
       | FLOAT_LITERAL  | STRING_LITERAL 
       | BOOL_LITERAL   | NULLPTR
       | user_defined_literal


operator: NEW            | DELETE         | NEW_ARRAY
        | DELETE_ARRAY   | PLUS           | MINUS
        | STAR           | SLASH          | PERCENT
        | BIT_XOR        | BIT_AND        | BIT_OR
        | BIT_NOT        | NOT            | EQUAL
        | LT             | GT             | PLUS_EQUAL
        | MINUS_EQUAL    | STAR_EQUAL     | SLASH_EQUAL
        | PERCENT_EQUAL  | BIT_XOR_EQUAL  | BIT_AND_EQUAL
        | BIT_OR_EQUAL   | SHL            | SHR
        | SHL_EQUAL      | SHR_EQUAL      | EQ
        | NEQ            | LE             | GE
        | AND            | OR             | INCREMENT
        | DECREMENT      | _COMMA         | ARROW
        | ARROW_STAR     | DOT_STAR       | ELLIPSIS
        | CALL           | SUBSCRIPT


punctuator: _LBRACE     | _RBRACE  | _LBRACKET
          | _RBRACKET   | _LPAREN  | _RPAREN
          | _SEMICOLON  | _COMMA   | _DOT
          | DOT_STAR    | ARROW    | ARROW_STAR
          | COLON       | SCOPE    | ELLIPSIS

keyword:   _IF             | ELSE           | SWITCH         | CASE
         | DEFAULT         | FOR            | WHILE          | DO
         | BREAK           | CONTINUE       | RETURN         | GOTO
         | TRY             | CATCH          | THROW          | INT
         | FLOAT           | DOUBLE         | CHAR           | WCHAR_T
         | CHAR16_T        | CHAR32_T       | VOID           | BOOL
         | AUTO            | SIGNED         | UNSIGNED       | SHORT
         | LONG            | CONST          | CONSTEXPR      | CONSTEVAL
         | VOLATILE        | STATIC         | EXTERN         | MUTABLE
         | REGISTER        | RESTRICT       | INLINE         | VIRTUAL
         | EXPLICIT        | NOEXCEPT       | FINAL          | OVERRIDE
         | THREAD_LOCAL    | TYPENAME       | CLASS          | STRUCT
         | UNION           | ENUM           | NAMESPACE      | TEMPLATE
         | TYPEDEF         | USING          | FRIEND         | PUBLIC
         | PRIVATE         | PROTECTED      | STATIC_ASSERT  | ASM
         | DECLTYPE        | THIS


# ===== User-defined literals =====
user_defined_literal: user_defined_integer_literal
  | user_defined_floating_literal
  | user_defined_string_literal
  | user_defined_character_literal

user_defined_integer_literal:   INT_LITERAL    ud_suffix
user_defined_floating_literal:  FLOAT_LITERAL  ud_suffix
user_defined_string_literal:    STRING_LITERAL ud_suffix
user_defined_character_literal: CHAR_LITERAL   ud_suffix

ud_suffix: IDENTIFIER


########################################################################################################################
#  A.4 EXPRESSIONS  #
#####################
# ISO C++

primary_expression: literal
                  | THIS
                  | id_expression
                  | lambda_expression
                  | ambiguous_cast             # <- Disambiguation Wrapper
#ISO:             | _LPAREN expression _RPAREN # <- Collapsed into cast_expression

# Original Rule (Non-ISO):
ambiguous_cast: cast_expression # <- Ambiguity Collapsed within wrapper

id_expression: unqualified_id
             | qualified_id

unqualified_id: IDENTIFIER
              | operator_function_id
              | conversion_function_id
              | literal_operator_id
              | BIT_NOT decltype_specifier
              | template_id
              | BIT_NOT ambiguous_identifier   # <- Pruned class_name
              | BIT_NOT simple_template_id     # <- Lifted from class_name
#ISO:         | BIT_NOT class_name


qualified_id: SCOPE? nested_name_specifier TEMPLATE? unqualified_id
            | SCOPE IDENTIFIER 
            | SCOPE operator_function_id   
            | SCOPE literal_operator_id
            | SCOPE template_id

#ISO: nested_name_specifier: type_name          SCOPE
#                          | namespace_name     SCOPE
#                          | decltype_specifier SCOPE
#                          | nested_name_specifier IDENTIFIER SCOPE
#                          | nested_name_specifier TEMPLATE? simple_template_id SCOPE

nested_name_specifier: ambiguous_identifier SCOPE # <- Pruned type_name U namespace_name
                     | simple_template_id   SCOPE # <- Lifted from type_name
                     | decltype_specifier   SCOPE
                     | nested_name_specifier IDENTIFIER SCOPE
                     | nested_name_specifier TEMPLATE? simple_template_id SCOPE

lambda_expression: lambda_introducer lambda_declarator? compound_statement

lambda_introducer: _LBRACKET lambda_capture? _RBRACKET

lambda_capture: capture_default
              | capture_list
              | capture_default _COMMA capture_list

capture_default: BIT_AND
               | EQUAL

capture_list: capture ELLIPSIS?
            | capture_list _COMMA capture ELLIPSIS?

capture: IDENTIFIER
       | BIT_AND IDENTIFIER
       | THIS

lambda_declarator: _LPAREN parameter_declaration_clause _RPAREN attribute_specifier? MUTABLE?
                 | exception_specification? trailing_return_type?

postfix_expression: primary_expression
                  | postfix_expression _LBRACKET expression _RBRACKET       -> array_subscript
                  | postfix_expression _LBRACKET braced_init_list _RBRACKET -> array_or_dereference
                  | postfix_expression _LPAREN expression_list? _RPAREN     -> call 
#                  | simple_type_specifier _LPAREN expression_list? _RPAREN  -> c_cast_or_dir_init_simple
                  | typename_specifier _LPAREN expression_list? _RPAREN     -> dir_init_class_or_ctor_call
  
                  | simple_type_specifier braced_init_list
                  | typename_specifier braced_init_list
                  | postfix_expression _DOT TEMPLATE? id_expression
                  | postfix_expression ARROW TEMPLATE? id_expression
                  | postfix_expression _DOT pseudo_destructor_name
                  | postfix_expression ARROW pseudo_destructor_name
                  | postfix_expression INCREMENT                          
                  | postfix_expression DECREMENT
                  | DYNAMIC_CAST LT type_id GT _LPAREN expression _RPAREN
                  | STATIC_CAST LT type_id GT _LPAREN expression _RPAREN
                  | REINTERPRET_CAST LT type_id GT _LPAREN expression _RPAREN
                  | CONST_CAST LT type_id GT _LPAREN expression _RPAREN
                  | TYPEID _LPAREN expression _RPAREN
                  | TYPEID _LPAREN type_id _RPAREN

expression_list: initializer_list

pseudo_destructor_name: SCOPE? nested_name_specifier? type_name SCOPE BIT_NOT type_name
                      | SCOPE? nested_name_specifier TEMPLATE simple_template_id SCOPE BIT_NOT type_name
                      | SCOPE? nested_name_specifier? BIT_NOT type_name
                      | BIT_NOT decltype_specifier

unary_expression: postfix_expression
                | INCREMENT cast_expression
                | DECREMENT cast_expression
                | unary_operator cast_expression
                | SIZEOF unary_expression
                | SIZEOF _LPAREN type_id _RPAREN
                | SIZEOF ELLIPSIS _LPAREN IDENTIFIER _RPAREN
                | ALIGNOF _LPAREN type_id _RPAREN
                | noexcept_expression
                | new_expression
                | delete_expression

unary_operator: STAR
              | BIT_AND
              | PLUS
              | MINUS
              | NOT
              | BIT_NOT

new_expression: SCOPE? NEW new_placement? new_type_id new_initializer?
              | SCOPE? NEW new_placement? _LPAREN type_id _RPAREN new_initializer?

new_placement: _LPAREN expression_list _RPAREN

new_type_id: type_specifier_seq new_declarator?

#ISO: new_declarator: ptr_operator new_declarator?
#                   | noptr_new_declarator
new_declarator: declarator_prefix new_declarator_suffix

# Original Rule (Non-ISO):
new_declarator_suffix: _LBRACKET expression          _RBRACKET # dynamic bound
                     | _LBRACKET constant_expression _RBRACKET # static bound

#ISO: noptr_new_declarator: _LBRACKET expression _RBRACKET attribute_specifier?
#                         | noptr_new_declarator _LBRACKET constant_expression _RBRACKET attribute_specifier?

new_initializer: _LPAREN expression_list? _RPAREN
               | braced_init_list

delete_expression: SCOPE? DELETE cast_expression
                 | SCOPE? DELETE _LBRACKET _RBRACKET cast_expression

noexcept_expression: NOEXCEPT _LPAREN expression _RPAREN

cast_expression: unary_expression
               | _LPAREN type_id _RPAREN cast_expression # C Style Cast   (int)var;
                                                         # C++ Style Cast int(var); <- includes: static, constant, dynamic, reinterpret

pm_expression: cast_expression
             | pm_expression DOT_STAR   cast_expression
             | pm_expression ARROW_STAR cast_expression

multiplicative_expression: pm_expression
                         | multiplicative_expression STAR pm_expression
                         | multiplicative_expression SLASH pm_expression
                         | multiplicative_expression PERCENT pm_expression

additive_expression: multiplicative_expression
                   | additive_expression PLUS multiplicative_expression
                   | additive_expression MINUS multiplicative_expression

shift_expression: additive_expression
                | shift_expression SHL additive_expression
                | shift_expression SHR additive_expression

relational_expression: shift_expression
                     | relational_expression LT shift_expression
                     | relational_expression GT shift_expression
                     | relational_expression LE shift_expression
                     | relational_expression GE shift_expression

equality_expression: relational_expression
                   | equality_expression EQ relational_expression
                   | equality_expression NEQ relational_expression

and_expression: equality_expression
              | and_expression BIT_AND equality_expression

exclusive_or_expression: and_expression
                       | exclusive_or_expression BIT_XOR and_expression

inclusive_or_expression: exclusive_or_expression
                       | inclusive_or_expression BIT_OR exclusive_or_expression

logical_and_expression: inclusive_or_expression
                      | logical_and_expression AND inclusive_or_expression

logical_or_expression: logical_and_expression
                     | logical_or_expression OR logical_and_expression

conditional_expression: logical_or_expression
                      | logical_or_expression TERNARY expression COLON assignment_expression

assignment_expression: conditional_expression
                     | logical_or_expression assignment_operator initializer_clause
                     | throw_expression

assignment_operator: EQUAL        | STAR_EQUAL
                   | SLASH_EQUAL  | PERCENT_EQUAL
                   | PLUS_EQUAL   | MINUS_EQUAL
                   | SHR_EQUAL    | SHL_EQUAL
                   | BIT_OR_EQUAL | BIT_XOR_EQUAL
                   | BIT_AND_EQUAL

#ISO: expression: assignment_expression
#               | expression _COMMA assignment_expression
expression: assignment_expression (_COMMA assignment_expression)* # <- Left-Recursion Eliminated

constant_expression: conditional_expression


########################################################################################################################
#  A.5  STATEMENTS  #
#####################

statement: labeled_statement
         | attribute_specifier? expression_statement
         | attribute_specifier? compound_statement
         | attribute_specifier? selection_statement
         | attribute_specifier? iteration_statement
         | attribute_specifier? jump_statement
         | declaration_statement
         | attribute_specifier? try_block

labeled_statement: attribute_specifier? IDENTIFIER COLON statement
                 | attribute_specifier? CASE constant_expression COLON statement
                 | attribute_specifier? DEFAULT COLON statement

#ISO: expression_statement: expression? _SEMICOLON
expression_statement: expression _SEMICOLON # <- Collapsed Ambiguity into empty_declaration

compound_statement: _LBRACE statement_seq? _RBRACE

#ISO: statement_seq: statement
#                  | statement_seq statement
statement_seq: statement+ # <- Eliminated Left-Recursion

selection_statement: _IF _LPAREN condition _RPAREN statement
                   | _IF _LPAREN condition _RPAREN statement ELSE statement
                   | SWITCH _LPAREN condition _RPAREN statement

condition: expression
         | attribute_specifier? type_specifier_seq declarator EQUAL initializer_clause
         | attribute_specifier? type_specifier_seq declarator braced_init_list

iteration_statement: WHILE _LPAREN condition _RPAREN statement
                   | DO statement WHILE _LPAREN expression _RPAREN _SEMICOLON
                   | FOR _LPAREN for_init_statement condition? _SEMICOLON expression? _RPAREN statement
                   | FOR _LPAREN for_range_declaration COLON expression _RPAREN statement

for_init_statement: expression_statement
                  | simple_declaration

for_range_declaration: attribute_specifier? type_specifier_seq declarator

jump_statement: BREAK _SEMICOLON
              | CONTINUE _SEMICOLON
              | RETURN expression? _SEMICOLON
              | RETURN braced_init_list _SEMICOLON
              | GOTO IDENTIFIER _SEMICOLON

declaration_statement: block_declaration

########################################################################################################################
#   ENTRY POINT  #
##################

?start: translation_unit

########################################################################################################################
#   A.3 BASIC CONCEPTS  #
#########################

translation_unit: declaration_seq?

#external_declaration: declaration # REMOVE SOON

########################################################################################################################
#  A.6 DECLARATIONS  #
######################

# ISO C++ Declarations
declaration_seq: declaration+

declaration: block_declaration
           | function_definition
           | template_declaration
           | explicit_instantiation
           | explicit_specialization
           | linkage_specification
           | namespace_definition
           | attribute_declaration
           | empty_declaration

block_declaration: simple_declaration
                 | asm_definition
                 | namespace_alias_definition
                 | using_declaration
                 | using_directive
                 | static_assert_declaration
                 | alias_declaration
                 | opaque_enum_declaration


########################################################################################################################
#  A.6.2 PRIMARY DECLARATIONS  #
################################

##########################
#  TEMPLATE DECLARATION  #  -> Expanded in A.12 TEMPLATES
##########################
template_declaration: TEMPLATE LT template_parameter_list GT declaration

############################
#  EXPLICIT INSTANTIATION  #
############################
explicit_instantiation: EXTERN? TEMPLATE declaration

#############################
#  EXPLICIT SPECIALIZATION  #
#############################
explicit_specialization: TEMPLATE LT GT declaration

###########################
#  LINKAGE SPECIFICATION  #
###########################
linkage_specification: EXTERN STRING_LITERAL _LBRACE declaration_seq? _RBRACE
                     | EXTERN STRING_LITERAL declaration

##########################
#  NAMESPACE DEFINITION  #
##########################
namespace_definition: named_namespace_definition
                    | unnamed_namespace_definition

#ISO: named_namespace_definition: original_namespace_definition  <- Collapsed ambiguity
#                               | extension_namespace_definition <- Collapsed ambiguity
named_namespace_definition: INLINE? NAMESPACE namespace_name _LBRACE namespace_body _RBRACE
# |--> Lifted from extension 'ext_namespace_def' & 'original_namespace_def"

#ISO: extension_namespace_definition: INLINE? NAMESPACE original_namespace_name _LBRACE namespace_body _RBRACE

#ISO: original_namespace_definition: INLINE? NAMESPACE IDENTIFIER _LBRACE namespace_body _RBRACE

unnamed_namespace_definition: INLINE? NAMESPACE _LBRACE namespace_body _RBRACE

qualified_namespace_specifier: SCOPE? nested_name_specifier? namespace_name
#                      SCOPE + namespace_name = global
# nested_namespace_specifier + namespace_name = qualified

namespace_body: declaration_seq # declaration_seq?

##################################################
#  ATTRIBUTE DECLARATION & ATTRIBUTE SPECIFIER   #
##################################################
attribute_declaration: attribute_specifier _SEMICOLON

attribute_specifier: _LBRACKET _LBRACKET attribute_list? _RBRACKET _RBRACKET

attribute_list: attribute (_COMMA attribute)* ELLIPSIS?

attribute: attribute_token attribute_argument_clause?

attribute_token: IDENTIFIER
               | attribute_scoped_token

attribute_scoped_token: attribute_namespace SCOPE IDENTIFIER

attribute_namespace: IDENTIFIER

attribute_argument_clause: _LPAREN balanced_token_seq _RPAREN

balanced_token_seq: balanced_token+

balanced_token: _LPAREN   balanced_token_seq  _RPAREN
              | _LBRACKET balanced_token_seq  _RBRACKET
              | _LBRACE    balanced_token_seq _RBRACE
#             | any token other than a parenthesis, a bracket, or a brace

########################
#  EMPTY DECLARATION  #
#######################
empty_declaration: _SEMICOLON



########################################################################################################################
#  A.6.1 SECONDARY DECLARATIONS  #  <- derived from block_declaration
##################################

########################
#  SIMPLE DECLARATION  #
########################
simple_declaration: attribute_specifier? decl_specifier_seq init_declarator_list? _SEMICOLON
# ^--> contains: variable_declaration, function_declaration, typedef_alias, user_defined_types

#########################
#  ASSEMBLY DEFINITION  #
#########################
asm_definition: ASM _LPAREN STRING_LITERAL _RPAREN _SEMICOLON

################################
#  NAMESPACE ALIAS DEFINITION  #
################################
namespace_alias_definition: NAMESPACE IDENTIFIER EQUAL qualified_namespace_specifier _SEMICOLON

#######################
#  USING DECLARATION  #
#######################
using_declaration: USING type_name? SCOPE? nested_name_specifier unqualified_id _SEMICOLON
                 | USING SCOPE unqualified_id _SEMICOLON

#####################
#  USING DIRECTIVE  #
#####################
#using_directive: attribute_specifier? USING NAMESPACE SCOPE? nested_name_specifier? namespace_name _SEMICOLON
using_directive: attribute_specifier? USING NAMESPACE SCOPE? ambiguous_identifier _SEMICOLON
# uncomment once nested_name_specifier is non-ambiguous

#ISO: namespace_name: ambiguous_identifier <- Pruned into ambiguous_identifier
#                   | namespace_alias
namespace_name: ambiguous_identifier # <- Re-aliased into ambiguous_identifier

#ISO: original_namespace_name: IDENTIFIER <- Pruned into ambiguous_identifier

#ISO: namespace_alias: IDENTIFIER <- Pruned into ambiguous_identifier

######################
# ALIAS DECLARATION  # -> It's a more powerful version of typedef that can alias templates.
######################
alias_declaration: USING IDENTIFIER EQUAL type_id _SEMICOLON
# Example: using newTypeName = existingTypeName;

###############################
#  STATIC ASSERT DECLARATION  #
###############################
static_assert_declaration: STATIC_ASSERT _LPAREN constant_expression _COMMA STRING_LITERAL _RPAREN _SEMICOLON

#############################
#  OPAQUE ENUM DECLARATION  #
#############################
opaque_enum_declaration: enum_key attribute_specifier? IDENTIFIER enum_base? _SEMICOLON

enum_key: ENUM
        | ENUM CLASS
        | ENUM STRUCT

enum_base: COLON type_specifier_seq

enumerator_list: enumerator_definition
               | enumerator_list _COMMA enumerator_definition

enumerator_definition: enumerator
                     | enumerator EQUAL constant_expression

enumerator: IDENTIFIER

#ISO: enum_name: IDENTIFIER <- Pruned into ambiguous_identifier

# ENUM as a TYPE SPECIFIER:
enum_specifier: enum_head _LBRACE enumerator_list? _RBRACE
              | enum_head _LBRACE enumerator_list _COMMA _RBRACE

enum_head: enum_key attribute_specifier? IDENTIFIER? enum_base?
         | enum_key attribute_specifier? nested_name_specifier IDENTIFIER
         | enum_base?


#
#parameter_declaration: attribute_specifier? decl_specifier_seq declarator
#                     | attribute_specifier? decl_specifier_seq declarator EQUAL assignment_expression
#                     | attribute_specifier? decl_specifier_seq abstract_declarator?
#                     | attribute_specifier? decl_specifier_seq abstract_declarator? EQUAL assignment_expression

########################################################################################################################
# Legacy - Production
#function_definition: decl_specifier_seq declarator compound_statement

#########################
#  FUNCTION DEFINITION  #
#########################
function_definition: attribute_specifier? decl_specifier_seq? declarator function_body
                   | attribute_specifier? decl_specifier_seq? declarator EQUAL DEFAULT _SEMICOLON
                   | attribute_specifier? decl_specifier_seq? declarator EQUAL DELETE _SEMICOLON

function_body: ctor_initializer? compound_statement #  constructor_initializer
             | function_try_block                   #  try block handler

########################################################################################################################
#  A.6.3 TYPE SPECIFIERS  # -> Used in declarator.
###########################

decl_specifier: storage_class_specifier
              | type_specifier
              | function_specifier
              | FRIEND
              | TYPEDEF
              | CONSTEXPR

#ISO: decl_specifier_seq: decl_specifier attribute_specifier?
#                       | decl_specifier decl_specifier_seq

decl_specifier_seq: (decl_specifier attribute_specifier?)+ # <- Eliminated Right-Recursion

storage_class_specifier: REGISTER
                       | STATIC
                       | THREAD_LOCAL
                       | EXTERN
                       | MUTABLE

function_specifier: INLINE
                  | VIRTUAL
                  | EXPLICIT

#ISO: typedef_name: IDENTIFIER <- Pruned into ambiguous_identifier

type_specifier: trailing_type_specifier # also wraps simple_type_specifier
              | class_specifier
              | enum_specifier

trailing_type_specifier: simple_type_specifier
                       | elaborated_type_specifier
                       | typename_specifier
                       | cv_qualifier

#ISO: type_specifier_seq: type_specifier attribute_specifier?
#                       | type_specifier type_specifier_seq
type_specifier_seq: (type_specifier attribute_specifier?)+ # <- Eliminated Right-Recursion

trailing_type_specifier_seq: trailing_type_specifier attribute_specifier?
                           | trailing_type_specifier trailing_type_specifier_seq

simple_type_specifier: SCOPE? nested_name_specifier? type_name
                     | SCOPE? nested_name_specifier TEMPLATE simple_template_id
                     | CHAR
                     | CHAR16_T
                     | CHAR32_T
                     | WCHAR_T
                     | BOOL
                     | SHORT
                     | INT
                     | LONG
                     | SIGNED
                     | UNSIGNED
                     | FLOAT
                     | DOUBLE
                     | VOID
                     | AUTO
                     | decltype_specifier

#ISO: type_name: class_name
#          | enum_name
#          | typedef_name
type_name: ambiguous_identifier # <- Collapsed ambiguity
         | simple_template_id   # <- Lifted from class_name

decltype_specifier: DECLTYPE _LPAREN expression _RPAREN

elaborated_type_specifier: class_key attribute_specifier? SCOPE? nested_name_specifier? IDENTIFIER
                         | class_key SCOPE? nested_name_specifier TEMPLATE? simple_template_id
                         | ENUM SCOPE? nested_name_specifier? IDENTIFIER



########################################################################################################################
#  A.7 DECLARATORS  #
#####################

#ISO: init_declarator_list: init_declarator
#                         | init_declarator_list _COMMA init_declarator
init_declarator_list: init_declarator (_COMMA init_declarator)* # <- Right-Recursion Eliminated

init_declarator: declarator initializer?

#ISO: declarator: ptr_declarator # <- Fully Redefined
#               | noptr_declarator parameters_and_qualifiers trailing_return_type
declarator: declarator_prefix? declarator_name declarator_suffix? # Identifier Bound
          | declarator_name parameters_and_qualifiers trailing_return_type

########################################################################################################################
# A.7.1 DISAMBIGUATION OF ISO 'DECLARATOR' #
############################################

#################################################################################################
# Cause   : Mutual recursion between ptr_declarator and noptr_declarator (ambiguous structure). #
# Solution: Collapse/redefine into explicit prefix and suffix sequences to remove recursion.    #
#################################################################################################
# START - Original Grammar; (Non-ISO)

declarator_prefix: ptr_operator+ # <- Eliminated Nullable List

declarator_name: declarator_id attribute_specifier?
               | _LPAREN declarator _RPAREN # handles nested (identifier)

declarator_suffix: suffix+ # <- Remove Nullability ε

suffix: parameters_and_qualifiers -> function_suffix 
      | _LBRACKET constant_expression? _RBRACKET attribute_specifier? \
                                  -> array_suffix

# END - Original Grammar; (Non-ISO)
#################################################################################################


#ISO: ptr_declarator: noptr_declarator            # <- Mutual recursion (heavily ambiguous)
#                   | ptr_operator ptr_declarator #

#ISO: noptr_declarator: declarator_id attribute_specifier?
#                     | noptr_declarator parameters_and_qualifiers
#                     | noptr_declarator _LBRACKET constant_expression? _RBRACKET attribute_specifier?
#                     | _LPAREN ptr_declarator _RPAREN

parameters_and_qualifiers: _LPAREN parameter_declaration_clause _RPAREN attribute_specifier? cv_qualifier_seq? \
                           ref_qualifier? exception_specification?

trailing_return_type: ARROW trailing_type_specifier_seq abstract_declarator?

ptr_operator: STAR attribute_specifier? cv_qualifier_seq?
            | BIT_AND attribute_specifier?
            | AND attribute_specifier?
            | SCOPE? nested_name_specifier STAR attribute_specifier? cv_qualifier_seq?

# ISO: cv_qualifier_seq: cv_qualifier cv_qualifier_seq?
cv_qualifier_seq: cv_qualifier+ # <- Right-Recursion Eliminated

cv_qualifier: CONST
            | VOLATILE

ref_qualifier: BIT_AND # &
             | AND     # &&

declarator_id: ELLIPSIS? id_expression                  # => (ctor expects class_name)
#ISO:        | SCOPE? nested_name_specifier? class_name # -> Collapsed into id_expression

type_id: type_specifier_seq abstract_declarator?

# Nameless declarator
#ISO abstract_declarator: ptr_abstract_declarator                                                   # <- Redefined
#                       | noptr_abstract_declarator? parameters_and_qualifiers trailing_return_type # <- Redefined
#                       | ELLIPSIS                                                                  # => Non-ambiguous Branch
abstract_declarator: declarator_prefix declarator_suffix?           # <- Prefix-Bound
                   | declarator_suffix                              # <- Suffix-Bound 
                   | parameters_and_qualifiers trailing_return_type # <- Suffix-Bound
                   | declarator_prefix _LPAREN abstract_declarator _RPAREN declarator_suffix # <- Nested empty declarators 
                   | ELLIPSIS # => Original


# Binds prefix *, &, &&
#ptr_abstract_declarator: noptr_abstract_declarator
#                       | ptr_operator ptr_abstract_declarator?
#
## Binds suffix [], (), [][]
#noptr_abstract_declarator: noptr_abstract_declarator? parameters_and_qualifiers
#                         | noptr_abstract_declarator? _LBRACKET constant_expression _RBRACKET attribute_specifier?
#                         | _LPAREN ptr_abstract_declarator _RPAREN

parameter_declaration_clause: parameter_declaration_list? ELLIPSIS?
                            | parameter_declaration_list _COMMA ELLIPSIS

#ISO: parameter_declaration_list: parameter_declaration
#                               | parameter_declaration_list _COMMA parameter_declaration
parameter_declaration_list: parameter_declaration (_COMMA parameter_declaration)* # <- Right-Recursion Eliminated

parameter_declaration: attribute_specifier? decl_specifier_seq declarator
                     | attribute_specifier? decl_specifier_seq declarator EQUAL assignment_expression
                     | attribute_specifier? decl_specifier_seq abstract_declarator?
                     | attribute_specifier? decl_specifier_seq abstract_declarator? EQUAL assignment_expression

initializer: brace_or_equal_initializer
           | _LPAREN expression_list _RPAREN

brace_or_equal_initializer: EQUAL initializer_clause
                          | braced_init_list

initializer_clause: assignment_expression
                  | braced_init_list

initializer_list: initializer_clause (_COMMA initializer_clause)* ELLIPSIS?


braced_init_list: _LBRACE initializer_list _COMMA? _RBRACE
                | _LBRACE _RBRACE



########################################################################################################################
#  A.8 CLASSES  #
#################

#ISO: class_name: IDENTIFIER          <- Pruned into ambiguous_identifier
#               | simple_template_id  <- Factor out non-ambiguity

class_specifier: class_head _LBRACE member_specification? _RBRACE

class_head: class_key attribute_specifier? IDENTIFIER? base_clause?
          | class_key attribute_specifier? nested_name_specifier IDENTIFIER base_clause?
          | class_key attribute_specifier? nested_name_specifier? simple_template_id base_clause?

class_key: CLASS
         | UNION
         | STRUCT

member_specification: member_declaration member_specification?
                    | access_specifier COLON member_specification?

member_declaration: attribute_specifier? decl_specifier_seq?
                    | member_declarator_list? _SEMICOLON
                    | function_definition _SEMICOLON?
                    | SCOPE?
                    | nested_name_specifier TEMPLATE?
                    | unqualified_id _SEMICOLON
                    | using_declaration
                    | static_assert_declaration
                    | template_declaration

member_declarator_list: member_declarator
                      | member_declarator_list _COMMA member_declarator

member_declarator: declarator pure_specifier?
                 | declarator brace_or_equal_initializer?
                 | IDENTIFIER? attribute_specifier? COLON constant_expression
                 | IDENTIFIER? attribute_specifier? COLON

pure_specifier: EQUAL "0"

########################################################################################################################
#  A.9 DERIVED CLASSES  #
#########################

base_clause: COLON base_specifier_list

base_specifier_list: base_specifier ELLIPSIS?
                   | base_specifier_list _COMMA base_specifier ELLIPSIS?

base_specifier: attribute_specifier? base_type_specifier
              | attribute_specifier? VIRTUAL access_specifier? base_type_specifier
              | attribute_specifier? access_specifier VIRTUAL? base_type_specifier

class_or_decltype: decltype_specifier
                 | SCOPE? nested_name_specifier? ambiguous_identifier   # <- Pruned class_name
                 | SCOPE? nested_name_specifier? simple_template_id     # <- Lifted from class_name
#ISO:            | SCOPE? nested_name_specifier? class_name             # -> Collapsed ambiguity


base_type_specifier: class_or_decltype

access_specifier: PRIVATE
                | PROTECTED
                | PUBLIC

########################################################################################################################
#  A.10 SPECIAL MEMBER FUNCTIONS  #
###################################

conversion_function_id: OPERATOR conversion_type_id

conversion_type_id: type_specifier_seq conversion_declarator?

conversion_declarator: ptr_operator conversion_declarator?

ctor_initializer: COLON mem_initializer_list

mem_initializer_list: mem_initializer ELLIPSIS?
                    | mem_initializer _COMMA mem_initializer_list ELLIPSIS?

mem_initializer: mem_initializer_id _LPAREN expression_list? _RPAREN
               | mem_initializer_id braced_init_list

mem_initializer_id: class_or_decltype
                  | IDENTIFIER



########################################################################################################################
#  A.11 OVERLOADING  #
######################

operator_function_id: OPERATOR operator

literal_operator_id: OPERATOR STRING_LITERAL IDENTIFIER


########################################################################################################################
#  A.12 TEMPLATES  #  <- template_declaration: TEMPLATE LT template_parameter_list GT declaration
####################

template_parameter_list: template_parameter (_COMMA template_parameter)*

template_parameter: type_parameter
                  | parameter_declaration

type_parameter: CLASS ELLIPSIS? IDENTIFIER?
              | CLASS IDENTIFIER? EQUAL type_id
              | TYPENAME ELLIPSIS? IDENTIFIER?
              | TYPENAME IDENTIFIER? EQUAL type_id
              | TEMPLATE LT template_parameter_list GT CLASS ELLIPSIS? IDENTIFIER?
              | TEMPLATE LT template_parameter_list GT CLASS IDENTIFIER? EQUAL id_expression

simple_template_id: template_name LT template_argument_list? GT

template_id: simple_template_id
#           | operator_function_id LT template_argument_list? GT
#           | literal_operator_id LT template_argument_list? GT

template_name: IDENTIFIER

template_argument_list: template_argument ELLIPSIS?
                      | template_argument_list _COMMA template_argument ELLIPSIS?

template_argument: constant_expression
                 | type_id
                 | id_expression

typename_specifier: TYPENAME SCOPE? nested_name_specifier IDENTIFIER
                   | TYPENAME SCOPE? nested_name_specifier TEMPLATE? simple_template_id

# explicit_instantiation: EXTERN? TEMPLATE declaration
# |-> Both found in A.6.1
# explicit_specialization: TEMPLATE LT GT declaration


########################################################################################################################
#  A.13 EXCEPTION HANDLING  #
#############################

try_block: TRY compound_statement handler_seq

function_try_block: TRY ctor_initializer? compound_statement handler_seq

handler_seq: handler handler_seq?

handler: CATCH _LPAREN exception_declaration _RPAREN compound_statement

exception_declaration: attribute_specifier? type_specifier_seq declarator
                     | attribute_specifier? type_specifier_seq abstract_declarator?
                     | ELLIPSIS

throw_expression: THROW assignment_expression?

exception_specification: dynamic_exception_specification
                       | noexcept_specification

dynamic_exception_specification: THROW _LPAREN type_id_list? _RPAREN

type_id_list: type_id ELLIPSIS?
            | type_id_list _COMMA type_id ELLIPSIS?

noexcept_specification: NOEXCEPT _LPAREN constant_expression _RPAREN
                      | NOEXCEPT




########################################################################################################################
#  RULESET  #
#############

%import common.WS
%ignore WS
%ignore COMMENT_LINE
%ignore COMMENT_BLOCK