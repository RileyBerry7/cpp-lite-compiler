// grammar.lark

########################################################################################################################
#   ENTRY POINT  #
##################

?start: translation_unit

translation_unit: external_declaration*

external_declaration: function_definition
# AMBIGUITY         | function_declaration
                    | declaration


########################################################################################################################
#  DECLARATORS  #
#################

function_definition:  declaration_specifier_list declarator compound_statement

# REMOVE AMBIGUITY
#function_declaration: declaration_specifier_list declarator _SEMICOLON

declaration: declaration_specifier_list initializer_declarator_list? _SEMICOLON

initializer_declarator_list: init_declarator ( _COMMA init_declarator )* _COMMA?

init_declarator:  declarator
               |  declarator EQUAL initializer

?initializer: expression
            | _LBRACE initializer_list? _RBRACE

initializer_list: initializer ( _COMMA initializer )* _COMMA?

############################################
# MUTUALLY EXCLUSIVE DECLARATOR STRUCTURE  #
############################################

declarator: ptr_operator declarator
          | direct_declarator

ptr_operator: (qualified_type_name SCOPE)? STAR cv_qualifier_seq?  -> ptr_to_member_or_ptr
            | BIT_AND                                              -> lvalue_ref
            | AND                                                  -> rvalue_ref

qualified_type_name: IDENTIFIER (SCOPE IDENTIFIER)*

nested_name_specifier: (IDENTIFIER SCOPE)* IDENTIFIER SCOPE

cv_qualifier_seq: type_qualifier+

direct_declarator: IDENTIFIER
                 | _LPAREN declarator _RPAREN
                 | direct_declarator array_suffix
                 | direct_declarator function_suffix

array_suffix:    _LBRACKET constant_expression _RBRACKET
function_suffix: _LPAREN parameter_list _RPAREN

# MAY IMPLEMENT LATER
//abstract_declarator: ptr_operator? direct_abstract_declarator
//                   | ptr_operator
//
//direct_abstract_declarator: _LPAREN abstract_declarator _RPAREN
//                          | direct_abstract_declarator array_suffix
//                          | direct_abstract_declarator function_suffix

########################################################################################################################
# DECLARATOR SPECIFIERS  #
##########################

parameter_list: parameter ( _COMMA parameter )* ( _COMMA ELLIPSIS )?
              | ELLIPSIS                     // "..."

parameter: declaration_specifier_list declarator default_arg?   // named + default arguments
//       | declaration_specifier_list abstract_declarator? // unnamed

default_arg: EQUAL initializer

declaration_specifier_list: declaration_specifier+

?declaration_specifier:  storage_class_specifier
                       | type_specifier
                       | type_qualifier
                       | function_specifier
                       | FRIEND
                       | TYPEDEF
                       | INLINE
                       | CONSTEXPR

storage_class_specifier: AUTO | EXTERN | STATIC | REGISTER | MUTABLE

type_qualifier: CONST | VOLATILE | RESTRICT


type_specifier: simple_type_specifier
               | elaborated_type_specifier

simple_type_specifier: VOID | CHAR | INT | FLOAT | DOUBLE | BOOL
                     | SIGNED | UNSIGNED | SHORT | LONG
                     // | IDENTIFIER (for typedef names)

elaborated_type_specifier: CLASS IDENTIFIER | STRUCT IDENTIFIER | ENUM IDENTIFIER

function_specifier: INLINE | VIRTUAL | EXPLICIT



########################################################################################################################
#  EXPRESSIONS  #
#################

# Used For Array Sizes
constant_expression: conditional_expression

######################
#  PRECEDENCE ORDER  #  All the boolean/arithmetic precedence levels.
######################

# Lowest precedence (comma operator), left-associative
expression: assignment_expression (_COMMA assignment_expression)*

# Assignment: right-associative; allow any unary lhs (covers *p = x, a[i] = x, ++x = y is still rejected later)
assignment_expression: conditional_expression
                     | unary assign_op assignment_expression          -> assignment

# Ternary sits between assignment and ||; middle uses full expression, right side is conditional_expression
conditional_expression: logic_or ( TERNARY expression COLON conditional_expression )?

# || down to unary â€” same as you had, but now fed by conditional_expression above
logic_or: logic_or OR logic_and                          -> or
        | logic_and

logic_and: logic_and AND equality                         -> and
         | equality

equality: equality (EQ | NEQ) relational                 -> eq
        | relational

relational: relational (LT | GT | LE | GE) sum             -> rel_expr
          | sum

sum: sum (PLUS | MINUS) product                     -> add
   | product

product: product (STAR | SLASH | PERCENT) unary         -> mul
       | unary

unary: (INCREMENT | DECREMENT | PLUS | MINUS | NOT | BIT_NOT | STAR | BIT_AND) unary
     | postfix

# Open-ended chaining of calls, indexing, member access, ++/--
postfix: primary post_op*

primary: IDENTIFIER
       | literal
       | _LPAREN expression _RPAREN

post_op: _LPAREN argument_list? _RPAREN
       | _LBRACKET expression _RBRACKET
       | _DOT IDENTIFIER
       | ARROW IDENTIFIER
       | INCREMENT
       | DECREMENT

argument_list: expression ( _COMMA expression )*

literal: INT_LITERAL
       | FLOAT_LITERAL
       | CHAR_LITERAL
       | STRING_LITERAL
       | BOOL_LITERAL
       | NULLPTR

###########################################
# Helper for all the assignment operators
assign_op: EQUAL
         | PLUS_EQUAL
         | MINUS_EQUAL
         | STAR_EQUAL
         | SLASH_EQUAL
         | PERCENT_EQUAL
         | SHL_EQUAL
         | SHR_EQUAL
         | BIT_AND_EQUAL
         | BIT_OR_EQUAL
         | BIT_XOR_EQUAL



########################################################################################################################
#  STATEMENTS  #
################

?statement: jump_statement
          | selection_statement
          | iteration_statement
          | expression_statement
          | labeled_statement
          | compound_statement
          | declaration

compound_statement: _LBRACE statement* _RBRACE

expression_statement: [expression] _SEMICOLON


selection_statement: if_statement
                   | switch_statement

if_statement: _IF _LPAREN expression _RPAREN statement
            | _IF _LPAREN expression _RPAREN statement ELSE statement

switch_statement: SWITCH _LPAREN expression _RPAREN statement

iteration_statement: FOR _LPAREN for_init? expression? _SEMICOLON expression? _RPAREN statement
                   | WHILE _LPAREN expression _RPAREN statement
                   | DO statement WHILE _LPAREN expression _RPAREN _SEMICOLON

for_init: declaration
        | expression_statement

?jump_statement: return_statement
               | break_statement
               | continue_statement
               | goto_statement

return_statement: RETURN [expression] _SEMICOLON
break_statement: BREAK _SEMICOLON
continue_statement: CONTINUE _SEMICOLON
goto_statement: GOTO IDENTIFIER _SEMICOLON

labeled_statement: IDENTIFIER COLON statement
                 | CASE constant_expression COLON statement
                 | DEFAULT COLON statement


########################################################################################################################
#  TERMINALS (TOKENS)  #
########################

############################
#  IDENTIFIERS & LITERALS  #
############################

IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
INT_LITERAL: /0|[1-9][0-9]*/
FLOAT_LITERAL: /([0-9]+\.[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?/
CHAR_LITERAL:   /'([^'\\]|\\.)'/
STRING_LITERAL: /"(\\"|[^"\\])*"/
BOOL_LITERAL:   "true" | "false"
NULLPTR:        "nullptr"

##############################
#   KEYWORDS (CONTROL-FLOW)  #
##############################
_IF:         "if"
ELSE:       "else"
SWITCH:     "switch"
CASE:       "case"
DEFAULT:    "default"
FOR:        "for"
WHILE:      "while"
DO:         "do"
BREAK:      "break"
CONTINUE:   "continue"
RETURN:     "return"
GOTO:       "goto"

######################
#  KEYWORDS (TYPES)  #
######################
INT:        "int"
FLOAT:      "float"
DOUBLE:     "double"
CHAR:       "char"
VOID:       "void"
BOOL:       "bool"
AUTO:       "auto"
SIGNED:     "signed"
UNSIGNED:   "unsigned"
SHORT:      "short"
LONG:       "long"
CONST:      "const"
CONSTEXPR:  "constexpr"
VOLATILE:   "volatile"
STATIC:     "static"
EXTERN:     "extern"
MUTABLE:    "mutable"
REGISTER:   "register"
RESTRICT:   "restrict"
INLINE:     "inline"
VIRTUAL:    "virtual"
EXPLICIT:   "explicit"

##################
#    KEYWORDS    #
##################
CLASS:      "class"
STRUCT:     "struct"
UNION:      "union"
ENUM:       "enum"
NAMESPACE:  "namespace"
TEMPLATE:   "template"
TYPEDEF:    "typedef"
USING:      "using"
FRIEND:     "friend"
PUBLIC:     "public"
PRIVATE:    "private"
PROTECTED:  "protected"

#################
#   OPERATORS   #
#################
PLUS:       "+"
MINUS:      "-"
STAR:       "*"
SLASH:      "/"
PERCENT:    "%"
EQUAL:      "="
ELLIPSIS:    "..."
PLUS_EQUAL:    "+="
MINUS_EQUAL:   "-="
STAR_EQUAL:    "*="
SLASH_EQUAL:   "/="
PERCENT_EQUAL: "%="
SHL_EQUAL: "<<="
SHR_EQUAL: ">>="
BIT_AND_EQUAL: "&="
BIT_OR_EQUAL: "|="
BIT_XOR_EQUAL: "^="


LT:         "<"
GT:         ">"
LE:         "<="
GE:         ">="
EQ:         "=="
NEQ:        "!="

AND:        "&&"
OR:         "||"
NOT:        "!"
BIT_AND:    "&"
BIT_OR:     "|"
BIT_NOT:    "~"
BIT_XOR:    "^"
SHL:        "<<"
SHR:        ">>"

INCREMENT:  "++"
DECREMENT:  "--"
ARROW:      "->"
TERNARY:    "?"
SCOPE: "::"
COLON:      ":"

##################
#   PUNCTUATION  #
##################
_LPAREN:     "("
_RPAREN:     ")"
_LBRACE:     "{"
_RBRACE:     "}"
_LBRACKET:   "["
_RBRACKET:   "]"
_SEMICOLON:  ";"
_COMMA:      ","
_DOT:        "."

###################
#  MISCELLANEOUS  #
###################
HASH:            "#"
INCLUDE:         "include"
DEFINE:          "define"
USING_NAMESPACE: "using"


########################################################################################################################
#  RULESET  #
#############

%import common.WS
%ignore WS